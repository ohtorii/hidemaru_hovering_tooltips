/*シンボルのコメントを表示する。

■用意するもの
	Exuberant Ctags
	（本家）
	http://hp.vector.co.jp/authors/VA025040/ctags/
	（日本語版）
	http://ctags.sourceforge.net/

	※手風琴氏作のCTagsJump009.lzhが導入済みなら、Exuberant Ctagsは導入済みです。


■前準備
	テキスト中の「コメント・文字列」は秀丸エディタから取得しています。
	秀丸エディタの設定をきちんと行っておいてください。

	以下手順、
	＊メニュー → その他 → ファイルタイプ別の設定 → 複数行コメント
		言語毎に設定してください。（多分、ここは皆さん大丈夫だと思います）

	＊メニュー → その他 → ファイルタイプ別の設定 → 強調表示
		「コメント・文字列」を独自に定義している場合は削除して、秀丸エディタ側に任せるようにしてください。

	（導入の敷居はちょっとだけ高いです、スイマセン）
*/



////////////////////////////////////////////////////////////////////////////////
//		メイン処理
////////////////////////////////////////////////////////////////////////////////

//
$g_ctag_search_filename = "ctags_search.exe";
$g_ctag_search_abs_path = "C:\\Users\\hoge\\Documents\\github\\hidemaru_hovering_tooltips\\src\\Release\\" + $g_ctag_search_filename;

$g_dengaku_filename = "DengakuDLL.dll";
$g_dengaku_abs_path =  hidemarudir + "\\" + $g_dengaku_filename;

$g_ini_filename 	= "hovering_tooltips_config.ini";
$g_ini_abs_path 	= currentmacrodirectory + "\\" + $g_ini_filename;

//「関数・シンボル」コメントを探す最大行数
#g_max_comment_lines=10;

//tagsの最大行数
#g_max_tags_lines=10;

//iniファイル：Pathの最大値（多分増やしても大丈夫なはず・・・）
#g_ini_path_max = 10;

//iniファイル：Priority[0-3]（ここは、３で固定）
#g_ini_priority_max=3;

//iniファイル：Priorityへ指定する文字列（小文字で指定すること）
//memo:もし、増減するようなことがあればMainPost関数内の処理も変更すること。
$g_ini_priority_string[0]	= "current";
$g_ini_priority_string[1]	= "path";
$g_ini_priority_string[2]	= "upperdir";
#g_ini_priority_string_num	= 3;


//DengakuDLLをロードしたかどうか
#g_load_dengaku = false;


//ParseCtagsLine関数の返値。
$g_ParseCtagsLineResult_Filename	= "";	//ファイル名
$g_ParseCtagsLineResult_Regex		= "";	//正規表現

/*ctagsファイルをパースした結果を格納する配列。
$Regexs[0...#g_NumTags]
$Filenames[0...#g_NumTags]
*/
$g_Regexs		= "";
$g_Filenames	= "";
#g_NumTags		= 0;

/*コメント
$Comments[0...N]
*/
$g_Comments = "";	//定義位置の前後にあるコメントを格納した配列
#g_NumComments=0;

/*	(.ini)ファイルの情報
*/
$g_ini_tags			= "tags";

$g_ini_path			= "";
#g_ini_path_num		= 0;

$g_ini_priority		= "";
#g_ini_priority_num	= 0;



call Main;
endmacro;

Main:
	disabledraw;
	disablehistory;
	disablebreak;
	disableinvert;
	$$old_searchbuffer = searchbuffer;
	##old_searchoption = searchoption;

	call MainPost;
	##ret =  ##return;

	setsearch $$old_searchbuffer, ##old_searchoption;
	call FreeDengakuDLL;
	return ##ret;


MainPost:
	call CheckEnvironment;
	if(! ##return){
		return false;
	}

	call GetSearchText;
	$$text = $$return;
	if("" == $$text){
		return false;
	}

	call ParseIni;
	##ret =  ##return;
	if(! ##ret){
		return false;
	}

	##ret=false;
	##i=0;
	while((##i < #g_ini_priority_num) && (! ##ret)){
		$$tags_abs_filename = "";
		$$priority = tolower($g_ini_priority[##i]);
		if("current"==$$priority){
			call MainPostDoCurrent $$text;
			##ret =  ##return;
		}else if("path"==$$priority){
			call MainPostDoPath $$text;
			##ret =  ##return;
		}else if("upperdir"==$$priority){
			call MainPostDoUpperDir $$text;
			##ret =  ##return;
		}else{
			//pass
		}

		##i = ##i + 1;
	}
	return ##ret;


MainPostDoCurrent:
	$$text = $$1;
	$$tags_abs_filename = directory+"\\"+$g_ini_tags;
	if(existfile($$tags_abs_filename, 1)){
		call GetTooltipString $$tags_abs_filename, $$text;
		##ret =  ##return;
		if(##ret){
			//コメントを抜き出した
			return true;
		}
	}
	return false;


MainPostDoPath:
	$$text 	= $$1;
	##i		= 0;
	while(##i < #g_ini_path_num){
		$$tags_abs_filename = $g_ini_path[##i]+"\\"+$g_ini_tags;
		if(existfile($$tags_abs_filename, 1)){
			call GetTooltipString $$tags_abs_filename, $$text;
			##ret =  ##return;
			if(##ret){
				//コメントを抜き出した
				return true;
			}
		}
		##i = ##i + 1;
	}
	return false;


MainPostDoUpperDir:
	$$text 	= $$1;
	##obj=createobject("Scripting.FileSystemObject");
	if(0==##obj){
		message("createobject(\"Scripting.FileSystemObject\"); に失敗");
		return false;
	}
	##i=0;
	##max=100;//無限ループ防止
	$$current = directory;
	while(##i<##max){
		$$current = callmethod_returnstr(##obj,"GetParentFolderName", $$current);
		if(0==strlen($$current)){
			break;
		}
		$$tags_abs_filename = $$current+"\\"+$g_ini_tags;
		if(existfile($$tags_abs_filename, 1)){
			call GetTooltipString $$tags_abs_filename, $$text;
			##ret =  ##return;
			if(##ret){
				//コメントを抜き出した
				releaseobject ##obj;
				return true;
			}
		}
		##i = ##i + 1;
	}
	releaseobject ##obj;
	return false;


GetSearchText:
	##old_column=column;
	##old_lineno=lineno;
	##cursor_restore = false;
	if(rectselecting){
		//pass
	}else if(selecting){
		//pass
	}else{
		##cursor_restore=true;
		selectword;
	}
	$$text = gettext2(seltopcolumn,seltoplineno,selendcolumn,selendlineno);
	if(##cursor_restore){
		escape;
		movetolineno ##old_column+1, ##old_lineno;
	}
	return  $$text;

//ctags_search.exe を起動してctagsのシンボルを取得する。
RunCtagsSearch:
	$$tags_abs_filename=$$1;
	$$text= $$2;
	$$exe = "\"" + $g_ctag_search_abs_path + "\"";
	$$tag = "\"" + $$tags_abs_filename + "\"";
	$$cmd = $$exe + " " + $$text + " " + $$tag;
	runex $$cmd
			, 1 			//sync	  0:async 1:sync
			, 0, "" 		//stdin   0:none 1:auto 2:file 3:(reserve) 4:all 5:select
			, 1, "" 		//stdout  0:none 1:auto 2:file 3:add file  4:new 5:insert 6:replace
			, 0, "" 		//stderr  0:none 1:=out 2:file 3:add file  4:new 5:insert 6:replace
			, 0, "" 		//folder  0:none 1:current 2:specify 3:(reserve) 4:exe's folder
			, 2 			//show	  0:auto 1:show 2:hide
			, 1 			//nodraw  0:draw 1:no draw
			, 0 			//unicode 0:ansi 2:unicode
			;
	##ret	= result;
	if(! ##ret){
		message("runexで失敗");
		return false;
	}
	##retex = getresultex(9);
	if(0 != ##retex){
		message($g_ctag_search_filename + "  のコマンドラインへの返値が失敗でした。\n");
		//endmacro;
		return false;
	}
	return true;


ParseCtagsLine:
	$$text = $$1;
	$$sep  = "\t";

	$g_ParseCtagsLineResult_Filename	= "";
	$g_ParseCtagsLineResult_Regex		= "";

	//シンボル名
	$token = dllfuncstr("GETTOKEN",$$text,$$sep);
	if (dllfunc("HASMORETOKENS") == 0) {
		return false;
	}

	//ファイル名
	$g_ParseCtagsLineResult_Filename = dllfuncstr("GETTOKEN","",$$sep);
	if (dllfunc("HASMORETOKENS") == 0) {
		return false;
	}

	//正規表現
	$g_ParseCtagsLineResult_Regex = dllfuncstr("GETTOKEN","",$$sep);
	if (dllfunc("HASMORETOKENS") == 0) {
		return false;
	}
	return true;


/*Perlの正規表現を秀丸の正規表現へ変換

（メモ）
高尚なことはしていません、正規表現文字列の前後を削っているだけです。

（例）
入力
	/^	struct SystemZRRIAddressMode {$/;"

出力
	  struct SystemZRRIAddressMode {

*/
PerlRegToHidemaruReg:
	$$text = $$1;
	##len = strlen($$text);

	//先頭の /^ を削除。
	$$str_head = "/^";
	##str_head_len = 2;
	if($$str_head == leftstr($$text,##str_head_len)){
		$$text = midstr($$text,##str_head_len, ##len - ##str_head_len);
		##len = ##len - ##str_head_len;
	}

	//末尾の $/;" を削除。
	$$str_tail = "$/;\"";
	##str_tail_len = 4;
	if($$str_tail == rightstr($$text,##str_tail_len)){
		$$text = midstr($$text,0,##len - ##str_tail_len);
	}

	return $$text;


ParseAllLine:
	##count 	= 0;
	##max_loop 	= #g_max_tags_lines;//最大ループ回数（無限ループ防止）
	##down_ret 	= true;
//$$aaa="";
	//一行ずつパースする
	while((##count<##max_loop) && ##down_ret){
		if(0==linelen2){
			break;
		}

		selectline;
		$$textline = gettext2(seltopcolumn,seltoplineno,selendcolumn,selendlineno);
		call ParseCtagsLine $$textline;
		if(! ##return){
			return false;
		}
		call PerlRegToHidemaruReg $g_ParseCtagsLineResult_Regex;
		//tagsファイルから抜き出した情報を保存しておく
		$g_Regexs[#g_NumTags]		= $$return;
		//$$aaa=$$aaa+ $$return + "\n";
		$g_Filenames[#g_NumTags]	= $g_ParseCtagsLineResult_Filename;
		#g_NumTags = #g_NumTags + 1;

		##count=##count+1;
		down;
		##down_ret=result;
	}
	//insert $$aaa;
	//endmacro;
	return true;


SearchRightWord:
	##color_code	= ##1;
	##prev_lineno	= lineno;
	right;
	##ret=result;
	while(##ret && (##prev_lineno==lineno)){
		if(##color_code == (0x0000001f & colorcode)){
			//コメント行である
			return true;
		}
		right;
		##ret=result;
	}
	
	return false;
	
	
/*前方の行からコメントを探す

コメントがあれば範囲選択する。
*/
ExtractCommentSingleFront:
	/*先頭方向の空白(\t\n )を読み飛ばす

	（メモ）
		#コメント １行目
		#コメント ２行目

		＜＜この行に空白があれば読み飛ばす＞＞

		int my_function(arg1, arg2) {
	*/
	##color_code = ##1;
	searchup "[^ \\t\\n]",regular ;

	##old_column=column+1;	//＋１してヒットした文字が範囲選択（後半で処理する）に含まれるようにしておく。
	##old_lineno=lineno;
	golinetop2;
	##cur_lineno = lineno;

	##has_comment=false;
	//先頭に向かって探す
	##max_loop	= #g_max_comment_lines;
	##cnt		= 0;
	##ret 		= true;
	while((##cnt < ##max_loop) && ##ret){
		if(##color_code != (0x0000001f & colorcode)){
			/*コメント以外が現れた

			コメント先頭の空白文字を読み飛ばして、コメントかどうかを更に調べる。
			（以下のようなコメントになっている）
				//コメント１
				//コメント２
			void function(zarg1,arg2){
			*/
			call SearchRightWord ##color_code;
			if(! ##return){
				goto LoopExitF_l;
			}
			golinetop2;
		}

		//コメント行である
		##has_comment=true;
		##cur_lineno = lineno;
		##cnt = ##cnt + 1;
		up;
		##ret=result;
	}

LoopExitF_l:
	if(##has_comment){
		//コメント行あり
		call SelectRange ##old_column, ##old_lineno, 0, ##cur_lineno;
	}
	return ##has_comment;


/*後方の行からコメントを探す

コメントがあれば範囲選択する。
*/
ExtractCommentSingleBack:
	/*後方方向の空白(\t\n )を読み飛ばす

	（メモ）
		int my_function(arg1, arg2) {

		＜＜この行に空白があれば読み飛ばす＞＞

		#コメント １行目
		#コメント ２行目
	*/
	##color_code = ##1;
	searchdown "[^ \\t\\n]",regular ;
	golinetop2;
	##old_column=column;
	##old_lineno=lineno;
	
	##cur_lineno= lineno;
	##cur_column = 0;
	
	##has_comment=false;
	//後方に向かって探す
	##max_loop	= #g_max_comment_lines;
	##cnt		= 0;
	##ret 		= true;
	while((##cnt < ##max_loop) && ##ret){
		if(##color_code != (0x0000001f & colorcode)){
			/*コメント以外が現れた

			コメント先頭の空白文字を読み飛ばして、コメントかどうかを更に調べる。
			（以下のようなコメントになっている）
			void function(zarg1,arg2){
				//コメント１
				//コメント２
			*/
			call SearchRightWord ##color_code;
			if(! ##return){
				goto LoopExitB_l;
			}
			golinetop2;
		}

		//コメント行である
		##has_comment=true;
		##cur_lineno = lineno;
		##cur_column = linelen2;
		##cnt = ##cnt + 1;
		down;
		##ret=result;
	}

LoopExitB_l:
	if(##has_comment){
		//コメント行あり
		call SelectRange ##old_column, ##old_lineno, ##cur_column, ##cur_lineno;
	}
	return ##has_comment;



//前後のコメントを抜き出す
ExtractCommentSingle:
	//「ファイル名＋行番号」
	//アウトプット枠へ出力したときにジャンプできるようにしておく。
	$$file_line = filename2 + "(" + str(lineno) + "):";

	selectline;
	//関数の行を抜き出す。
	$$func_text = gettext2(seltopcolumn,seltoplineno,selendcolumn,selendlineno);
	$$text_front="";
	$$text_back ="";
	
	golinetop2;
	##old_column=column;
	##old_lineno=lineno;
	
	
	//
	//前方コメント
	//
	call ExtractCommentSingleFront 0x00000003;
	##has_comment =  ##return;
	if(! ##has_comment){
		//コメント無し、文字列を探す。
		moveto2 ##old_column, ##old_lineno;
		call ExtractCommentSingleFront 0x00000014;
		##has_comment =  ##return;
	}
	
	if(##has_comment){
		//コメント行あり
		$$text_front = gettext2(seltopcolumn,seltoplineno,selendcolumn,selendlineno) + "\x0d\x0a";
	}
	
	
	//
	//後方コメント
	//
	moveto2 ##old_column, ##old_lineno;
	golineend2;
	call ExtractCommentSingleBack 0x00000003;
	##has_comment =  ##return;
	if(! ##has_comment){
		//コメント無し、文字列を探す。
		moveto2 ##old_column, ##old_lineno;
		golineend2;
		call ExtractCommentSingleBack 0x00000014;
		##has_comment =  ##return;
	}
	if(##has_comment){
		$$text_back = gettext2(seltopcolumn,seltoplineno,selendcolumn,selendlineno) + "\x0d\x0a";
	}

	return $$file_line + "\x0d\x0a" + $$text_front + $$func_text + $$text_back;


OpenFile:
	$$filename = $$1;
	if(existfile($$filename)){
		loadfile $$filename;
		//openfile "/m5 /h /r " + "\""	+ $$filename +"\"";
		//showwindow 0;
		if( ! readonly ) {
			readonlyswitch;
		}
		return result;
	}
	return false;


ExtractCommentAll:
	$$dir_name = $$1;
	if(#g_NumTags){
		setcompatiblemode 0x0050;

		##cnt = 0;
		$$prev_abs_filename = "";
		while(##cnt < #g_NumTags){
			$$abs_filename = $$dir_name + $g_Filenames[##cnt];
			if($$prev_abs_filename != $$abs_filename){
				call OpenFile $$abs_filename;
				##ret = ##return;
			}else{
				##ret = true;
			}

			if(##ret){
				gofiletop;
				searchdown2 $g_Regexs[##cnt], casesense, noregular, nohilight;
				if(result){
					call ExtractCommentSingle;
					$g_Comments[#g_NumComments] = $$return;
					#g_NumComments = #g_NumComments + 1;
				}
				$$prev_abs_filename = $$abs_filename;
			}

			##cnt = ##cnt + 1;
		}
	}
	return true;


//ディレクトリ名を取得する
GetDirName:
	$$filename = $$1;
	##n1 = strrstr($$filename,"\\");
	##n2 = strrstr($$filename,"/");
	if(##n1 < ##n2){
		##pos=##n2;
	}else{
		##pos=##n1;
	}
	if(-1 == ##pos){
		return $$filename;
	}
	//+1して区切り(\/)を込める
	return leftstr($$filename,##pos+1);

OutputComment:
	$$text = "";
	##cnt = 0;
	while(##cnt < #g_NumComments){
		$$text = $$text + "========================================================================\x0d\x0a" +
				$g_Comments[##cnt] + "\x0d\x0a";
		##cnt = ##cnt + 1;
	}
	if(1){
		call OpenOutput;
		call ClearOutput;
		##hdl = hidemaruhandle(0);
		##ret=dllfunc("Output",##hdl,$$text);
	}else{
		message($$text);
	}
	return ;


GetTooltipStringMain:
	$$tags_abs_filename = $$1;
	$$text				= $$2;

	call RunCtagsSearch $$tags_abs_filename, $$text;
	if(! ##return){
		return false;
	}

	//
	//現時点でこのようなテキストが得られている。
	//
	//Syntax	.\lib\MC\MCDisassembler\EDDisassembler.h	/^	  AssemblySyntax Syntax;$/;"    m   struct:llvm::EDDisassembler::CPUKey
	//SyntaxCheckTest	.\utils\lit\lit\LitFormats.py	/^from TestFormats import SyntaxCheckTest, OneCommandPerFileTest$/;"    i
	//

	//ctagsの１行をパースするためにdengaku-dllを使用します。
	call LoadDengakuDLL;
	if(! ##return){
		return false;
	}

	gofiletop;
	call ParseAllLine;
	if(! ##return){
		return false;
	}

	call GetDirName $$tags_abs_filename;
	$$dir_name = $$return;

	call ExtractCommentAll $$dir_name;
	if(! ##return){
		return false;
	}
	return true;


GetTooltipString:
	$$tags_abs_filename = $$1;
	$$text				= $$2;

	##old_hidemaru = hidemaruhandle(0);
	openfile "/h ";
	##new_hidemaru = hidemaruhandle(0);

	call GetTooltipStringMain $$tags_abs_filename,  $$text;
	##ret =  ##return;

	setactivehidemaru	##old_hidemaru;
	closehidemaruforced ##new_hidemaru;

	if(##ret){
		call OutputComment;
	}
	return ##ret;


SelectRange:
	escape;
	moveto2  ##1, ##2;
	beginsel;
	moveto2  ##3, ##4;
	endsel;
	return ;


OpenOutput:
	//アウトプット枠を開く
	loaddll "HmOutputPane.dll";
	#h=dllfunc("GetWindowHandle",hidemaruhandle(0));
	#ret=sendmessage(#h,0x111/*WM_COMMAND*/,1103 ,0);
	#ret=dllfunc("Push",hidemaruhandle(0));
	#ret=dllfunc("Pop",hidemaruhandle(0));
	return ;


ClearOutput:
	loaddll "HmOutputPane.dll";
	//アウトプット枠を開く
	#ret=dllfunc("Output",hidemaruhandle(0),"");
	//アウトプット枠をクリア
	#h=dllfunc("GetWindowHandle",hidemaruhandle(0));
	#ret=sendmessage(#h,0x111/*WM_COMMAND*/,1009,0);
	return ;


ParseIni:
	$$section = "Search";

	//tagsの解釈
	$$ret=getinistr($g_ini_abs_path,$$section,"Tags");
	if(""!=$$ret){
		$g_ini_tags=$$ret;
	}

	//Path[0-N]の解釈
	##i=0;
	while(##i < #g_ini_path_max){
		$$ret = getinistr($g_ini_abs_path,$$section,"Path"+str(##i));
		if("" == $$ret){
			break;
		}
		$g_ini_path[##i]=$$ret;
		##i = ##i + 1;
	}
	#g_ini_path_num = ##i;


	//Priority[0-3]の解釈
	##i=0;
	while(##i < #g_ini_priority_max){
		$$ret = getinistr($g_ini_abs_path,$$section,"Priority"+str(##i));
		if("" == $$ret){
			break;
		}
		call CheckIniPriorityString $$ret;
		if(! ##return){
			return false;
		}
		$g_ini_priority[##i]=$$ret;
		##i = ##i + 1;
	}
	#g_ini_priority_num=##i;

	return true;


CheckIniPriorityString:
	$$arg 	= $$1;
	$$text 	= tolower($$1);
	##i=0;
	while(##i < #g_ini_priority_string_num){
		if($$text == $g_ini_priority_string[##i]){
			return true;
		}
		##i = ##i + 1;
	}
	message("iniファイルの Priorityキー が間違っています。\n"	+
			"iniファイル："+$g_ini_abs_path + "\n"				+
			"間違っている値：" + $$arg + "\n"
	);
	return false;


LoadDengakuDLL:
	if(! #g_load_dengaku){
		loaddll $g_dengaku_abs_path;
		if (!result) {
			message $g_dengaku_filename + " をロードできませんでした。";
			return false;
		}
		//	ＤＬＬのバージョンチェック
		$$DLLVer = dllfuncstr("GETVERSION");
		if (val(leftstr($$DLLVer, 1)) < 2) {
			message "このマクロの実行には Ver.2.00 以降の田楽ＤＬＬが必要です。";
			freedll;
			return false;
		}

		#g_load_dengaku=true;
	}
	return true;

FreeDengakuDLL:
	if(#g_load_dengaku){
		freedll;
		#g_load_dengaku=false;
	}
	return;

//環境の検査
CheckEnvironment:
	if(! existfile($g_ctag_search_abs_path)){
		message("実行ファイルが見つかりません。\n"			+
				"マクロを再インストールして下さい。\n"	+
				$g_ctag_search_filename);
		return false;
	}

	return true;


